\chapter{Hello world}
O samym "hello world" mo¿na napisaæ bardzo du¿o. Wbrew pozorom du¿o siê dzieje, aby ten program zosta³ wypisany.
\section{Kod na start}

Poni¿ej macie s³awnego hello worlda. Nazywa siê tak program, jaki zwykle koder pisze, kiedy zaczyna pracê z nowym jêzykiem. Ca³oœæ polega na wypisaniu tekstu "hello world" na standardowe wyjœcie, które domyœlnie jest definiowane jako konsola.
\lstset{language=[Sharp]C,
   label=code:cmd,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapeinside={(*@}{@*)},
  basicstyle=\footnotesize,  
  stringstyle=\color{red},
  commentstyle=\color{OliveGreen},
  keywordstyle=\color{blue}\bf,
  columns=fullflexible,
  morekeywords={Process},
 emph={Console, System},emphstyle={\color{cyan}} 
}
\begin{lstlisting}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PierwszyProgram
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello world");
            Console.ReadKey();
        }
    }
}
\end{lstlisting}
Tak na prawdê napisa³am tylko liniê 13 i 14, reszta zosta³a dla mnie wygenerowana przez projekt konsolowy. Pierwsze co siê rzuca w oczy, to using. Kilka z nich jest na szaro, a to oznacza, ¿e mo¿emy je bez problemów usun¹æ. Mamy teraz coœ takiego:
\begin{lstlisting}
using System;
namespace PierwszyProgram
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello world");
            Console.ReadKey();
        }
    }
}
\end{lstlisting}
Zosta³ nam tylko jeden using. Ale na upartego i jego mo¿emy usun¹æ, acz musimy nieco zmodyfikowaæ kod, aby siê on skompilowa³.
\begin{lstlisting}
namespace PierwszyProgram
{
    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine("Hello world");
            System.Console.ReadKey();
        }
    }
}
\end{lstlisting}
Mo¿na ca³oœæ napisaæ jeszcze inaczej. Tak trochê dla fanów nowinek technicznych, bo kiedyœ nie mo¿na tak by³o napisaæ.
\begin{lstlisting}
using static System.Console;
namespace PierwszyProgram
{
    class Program
    {
        static void Main(string[] args)
        {
            WriteLine("Hello world");
            ReadKey();
        }
    }
}
\end{lstlisting}

Z ciekawych elementów jakie mo¿na tu opisaæ nale¿y wymieniæ:
\begin{itemize}
\item funkcja,
\item wywo³anie funkcji,
\item s³owo kluczowe using,
\item s³owo kluczowe namespace,
\item klasa,
\item s³owo kluczowe static,
\item standardowe wejœcie i wyjœcie - konsola,
\item funkcja Main,
\item entry point programu,
\item kompilacja i uruchomienie.
\end{itemize}

Tak¿e tym (niekoniecznie w tej kolejnoœci) siê bêdziemy spokojnie mogli zaj¹æ w pierwszym rozdziale.

\section{Funkcja}
Program bez funcji by nie istnia³, bo po co tworzyæ program, który nic nie robi. Ka¿dy z nich ma jak¹œ funkcjê, chyba ¿e jedyn¹ funkcj¹ programu jest to, ¿e ma siê uruchomiæ;) Ale aby siê uruchomi³, musi byæ jakaœ funkcja, no nie da siê inaczej. W przypadku C\# ta funkcja musi byæ umieszczona w jakiejœ klasie, ale nie wyprzedzajmy faktów. 
Zacznijmy od tego, w jaki sposób funkcjê mo¿na wywo³aæ.
Najproœciej mo¿na przedstawiæ jako 
Funkcja(parametry);
gdzie nazwa jest nazw¹ funkcji, zaœ parametry s¹ to informacje jakie podajemy funkcji. Na koñcu jest œrednik. Œrednik mówi programowi, ¿e skoñczyliœmy jeden "krok" programu.
Kiedy chcemy poznaæ wynik dzia³ania naszej funkcji, to (je¿eli zwraca wartoœæ) robimy

wynik = Funkcja(parametry);

Kiery mamy wiele parametrów, to je rozdzielamy przecinkami. Jak znamy nazwê mo¿emy j¹ podaæ przed dwukropkiem. Co nam da

wynik = Funkcja(parametr1, parametr2, parametr3);

albo

wynik = Funkcja(par1:parametr1, par2:parametr2, par3:parametr3);\\

Tak, wygl¹da trochê jak funkcja matematyczna i nic dziwnego. Ów zapis w jêzykach c-like by³ w³aœnie na tym wzorowany.

To co mo¿e zainteresowaæ bezpieczników czy mi³oœników optymalizacji, to kolejnoœæ przekazywania parametrów na stos. Programiœci c++ maj¹ doœæ spory wybór, o czym mo¿na przeczytaæ na msdn pod adresem \url{https://msdn.microsoft.com/pl-pl/library/984x0h58.aspx} my, programiœci c\# niekoniecznie.
Jak mo¿na przeczytaæ w \cite{ECMA-334} "During the run-time processing of a function member invocation (§7.5.4), the expressions or variable references of an argument list are evaluated in order, from left to right, (...)"  czyli zawsze mamy od lewej do prawej, czyli taki c++owy  \_\_clrcall. Wiêcej mo¿na przeczytaæ na \url{https://www.ecma-international.org/publications/files/ECMA-ST/Ecma-334.pdf}. Najlepiej zapisz sobie ten plik, bo bêdziemy do niego czêsto wracaæ.

To teraz spójrzmy na deklaracjê metody. Najogólniej by³oby to:

[atrybut] specyfikator\_dostêpu rodzaj wartoœæ\_zwracana nazwa(parametry) \{
  Tu wpisz jakiœ kod;
\}

Zaznaczê tylko, ¿e wielkoœæ liter (o ile nie napisano inaczej) ma znaczenie, wiêc funkcja o nazwie GetItem() i getItem() to dwie zupe³nie inne funkcje.

Mo¿na elementy pomijaæ, jednak kolejnoœæ ich zawsze musi byæ taka jak powy¿ej.
Atrybutami nie bêdziemy siê teraz zajmowaæ, dociekliwych odsy³am do \url{http://plukasiewicz.net/Csharp_dla_zaawansowanych/Atrybuty} gdzie mo¿na o tym poczytaæ.
Specyfikatory dostêpu to kolejno:
\begin{description}
\item[public] Mo¿na wywo³aæ metodê wszêdzie (oczywiœcie na zewn¹trz assembly trzeba dodaæ referencjê w projekcie)
\item[private] Mo¿na wywo³aæ wy³¹cznie w tej samej klasie, w której jest metoda. Przydatne przy enkapsulacji\footnote{Przyda siê jak bêdziemy omawiaæ programowanie obiektowe}.
\item[protected] Mo¿na wywo³aæ w klasie, oraz jej dzieciach (klasach dziedzicz¹cych po...).
\item[internal] Mo¿na wywo³aæ z poziomu tego konkretnego assembly
\item[protected internal] Zlepka dwóch poprzednich. Czyli jak w tym samym asembly to zewsz¹d, jak w innym, to tylko klasy dziedzicz¹ce.
\end{description}

Rodzaj, w tym schemacie to s³ówka takie jak static (wywo³ywane na rzecz klasy, nie obiektu), override (nadpisanie funkcji), new (przys³oniêcie funkcji), virtual (deklaracja funkcji któr¹ mo¿na nadpisaæ), abstract (funkcja bez cia³a w klasach abstrakcyjnych) itd.

wartoœæ zwracana, to wynik funkcji. Je¿eli nie zwracamy nic, wpisujemy void. Je¿eli zwracamy, to wpisujemy tutaj odpowiedni typ- albo predefiniowany, albo swój, ale typ musi istnieæ. Przyk³ady typów predefiniowanych to bool (prawda/fa³sz), int (liczba ca³kowita), float (;iczba zmiennoprzecinkowa), string(napis). Pe³na ich lista znajduje siê na \url{https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/built-in-types-table}

O parametrach napisa³am wy¿ej. Dodam, ¿e domyœlnie s¹ one przekazywane przez wartoœæ w przypadku typów wartoœciowych (value type) oraz przez referencjê w przypadku typów referencyjnych (reference type). Je¿eli chcemy zaœ zawsze przekazaæ przez referencjê, to przed parametrem dajemy ref lub out. Out nam inicjalizuje po wejœciu, a ref u¿ywa aktualnej wartoœci (wiêc musimy zainicjalizowaæ tak¹ zmienn¹ przed jej wys³aniem do funkcji).

Wracaj¹c do funkcji abstrakcyjnej (zwanej inaczej czysto wirtualn¹) to jest ona trochê œmieszna. Jej przyk³ad to:\\
public abstract void ZaimplementujMnie();\\
czyli œrednik od razu po nawiasach z parametrami, ¿adnych klamerek.

Ok, to ju¿ deklaracjê ka¿dy bêdzie umia³ przeczytaæ. Na razie o funkcjach wystarczy, z pewnoœci¹ wrócimy jeszcze do tego tematu. Zajmijmy siê kolejnym ciekawym zagadnieniem.
\section{Using i dllki}
Using tak na prawdê od strony wykonania programu nic nie robi. Czy wiêc jest leniwy? Niekoniecznie, ale powsta³ po to, abyœmy to my mogli byæ leniwi. Oszczêdza nam czas pisania na klawiaturze- co pokazuj¹ s³owa kluczowe powy¿ej. O ile przy dwóch linijkach dodawanie s³ówka System nie stanowi³o wiêkszego problemu, o tyle w skali du¿ej aplikacji powtarzanie w kó³ko tego samego okazuje siê zbêdne. Projektanci jêzyka dobrze znaj¹ zasadê DRY - Don't repeat yourself i pozwolili j¹ wdro¿yæ nawet na takim poziomie. 

Using nie jest analogi¹ do s³ówka import z innych jêzyków. Jak widaæ by³o powy¿ej, mo¿e tych usingów wcale nie byæ. S³ówko nie ³aduje do pamiêci ¿adnych modu³ów, a jedynie pozwala na skrócenie zapisu. Niezale¿nie od ich istnienia mamy dostêp do wszystkich funkcji jêzyka, oraz do podpiêtych bibliotek .dll.

Using nie jest te¿ odpowiednikiem s³ówka include znanego z c++, ¿adnych plików z nag³ówkami bowiem nie wkleja na pocz¹tek danego pliku. Mamy informacje o typach z naszego assembly oraz o typach do których dodaliœmy referencje bezpoœrednio w nag³ówkach, które mo¿na bezpoœrednio odczytaæ z naszego pliku .exe czy .dll. Wiêc using przypomina nieco frazê using namespace z c++, ale tylko w odniesieniu do przestrzeni nazw. Nie ma odpowiednika dla wywo³ywania funkcji statycznych (chyba, ¿e dodali od czasów, kiedy ostatnio mia³am ten jêzyk przed oczami, jakieœ 5 lat temu).

Aktualnie dodane dllki mo¿esz podejrzeæ w nastêpuj¹cy sposób:
\begin{enumerate}
\item Otwórz solution explorer (tam, gdzie s¹ pokazane pliki z projektu). Je¿eli znikn¹³ ci z oczu, daj ctrl+alt+l
\item Rozwiñ listê "references"
\item kliknij dwa razy któr¹œ z dodanych referencji (od pocz¹tku jest ich kilka)
\item uruchomi³ ci siê object explorer. Porozwijaj sobie listy po lewej i poklikaj
\end{enumerate}

Kolejne zadanie to zrobiæ to samo z dowolnie wybran¹ bibliotek¹.
\begin{enumerate}
\item Kliknij prawym na "references"
\item Kliknij "add reference"
\item Wybierz dowoln¹ bibliotekê z dysku lub z listy
\item Powtórz dla niej kroki z listy powy¿ej
\end{enumerate}

Teraz ju¿ wiesz drogi czytelniku w jaki sposób dowiedzieæ siê jakie funkcja ma typy, funkcje, propertiesy i tak dalej. Skoro ty jesteœ w stanie to doœæ prosto odczytaæ, to tym bardziej platforma.

Usingi na pocz¹tku pliku (using xx odnosi siê do namespace'ów, using static do klas statycznych) pomagaj¹ nam w szybszym pisaniu. Ale jest jeszcze jedno zastosowanie s³ówka using, które u³atwia nam ¿ycie, a ponad to pozwala na unikniêcie wycieków pamiêci i blokowania zasobów. U¿ywa siê go ju¿ wewn¹trz funkcji i przedstawia siê nastêpuj¹co:
\begin{lstlisting}
using (Zasobozerca obiekt = new Zasobozerca())
{
    obiekt.RobRobote();
}
\end{lstlisting}
co jest przez kompilator rozwijane do takiego kodu:
\begin{lstlisting}
{ 
    Zasobozerca obiekt = new Zasobozerca()
    try
    {
        obiekt.RobRobote();
    }
    finally
    {
        if (obiekt!= null)
            ((IDisposable)obiekt).Dispose();
    }
}
\end{lstlisting}
Obecnie mo¿e byæ on dla Ciebie nieczytelny, ale zrozumiesz go ju¿ wkrótce. Teraz tylko powiem, ¿e kod powy¿ej sprz¹ta po zasobo¿ercy, pod warunkiem, ¿e ten implementuje IDisposable. Oczywiœcie funkcja .Dispose() mo¿e robiæ cokolwiek, ale programiœci umówili siê, ¿e tak bêd¹ nazywaæ funkcjê, która sprz¹ta po obiekcie, kiedy ju¿ zakoñczy swoj¹ pracê.

Jednak leniwi programiœci zapominali wywo³ywaæ t¹ funkcjê, co powodowa³o, ¿e pamiêæ ciek³a, pliki by³y blokowane, wolne porty sieciowe siê koñczy³y i tak dalej. Wprowadzono zatem u³atwienie sk³adniowe, aby dbanie o zasoby mniej bola³o.

Tak¿e using nie jest leniwy, zaœ pozwala nam na pewne lenistwo.

\section{S³owo kluczowe namespace}